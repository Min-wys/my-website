## 两数之和

### 题目

- 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

- 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

- 你可以按任意顺序返回答案。

- 示例：

  ```JS
  输入：nums = [2,7,11,15], target = 9
  输出：[0,1]
  解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
  ```

### 方法一：暴力法

- 把所有数、两两组合在一起，计算它们的和，如果是target，就输出。

  ```TS
  // 方法一：暴力法  双重for循环
  var twoSum1 = function (nums, target) {
    for (let i = 0; i < nums.length; i++) {
      for (let j = 1 + i; j < nums.length; j++) {
        if (nums[i] + nums[j] === target) {
          return [i, j];
        }
      }
    }
  };
  ```

- 时间复杂度：O(n^2)，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)。

- 空间复杂度：O(1)。

### 方法二：使用对象存储数据，一次遍历

- 在遍历的时候将元素插入到表中的同时，我们可以直接检查表中是否已经存在当前元素所对应的目标元素。

- 如果它存在，那我们已经找到了对应解，并立即将其返回。这样，只需要扫描一次对象，就可以完成算法了。

- 可以想象成：你去相亲大会，你已经知道你要找的对象是谁，进入相亲大会，会记录之前已经来的人（obj记录），你就可以在obj中找你的对象是否已经来了

  ```js
  var twoSum = function (nums, target) {
    // key 是数组的值，value是数组的下标
    let obj = {};
  
    for (let i = 0; i < nums.length; i++) {
      if (obj[target - nums[i]] !== undefined && i !== obj[target - nums[i]]) {
        return [i, obj[target - nums[i]]];
      }
      obj[nums[i]] = i;
    }
  };
  ```

- 时间复杂度：O(N)，我们只遍历了包含有 N 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。其实这个过程中，我们也借鉴了动态规划的思想、把子问题解保存起来，后面用到就直接查询。

- 空间复杂度：O(N)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 N 个元素。

## 三数之和

### 题目

- 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

- **注意：**答案中不可以包含重复的三元组。

- 示例

  ```js
  输入：nums = [-1,0,1,2,-1,-4]
  输出：[[-1,-1,2],[-1,0,1]]
  ```

### 排序+双指针

1. 双指针：分为左右指针、快慢指针
2. 左右指针：其实借鉴的就是分治的思想，简单来说，就是在数组头尾各放置一个指针，先让头部的指针（左指针）右移，移不动的时候，再让尾部的指针（右指针）左移：最终两个指针相遇，那么搜索就结束了。
3. 双指针铺垫：先将给定 nums数组 排序，复杂度为 O(NlogN)。
   1. 首先，我们可以想到，数字求和，其实跟每个数的大小是有关系的，如果能先将数组排序，那后面肯定会容易很多。
4. 以 i 为核心进行遍历，左右指针与 i 进行相加判断是否为0

![](https://cdn.jsdelivr.net/gh/Min-wys/figure-bed/img/20220502161555.png)

```JS
var threeSum = function (nums) {
  // 保存结果
  let result = [];
  //  0.先排序
  nums.sort((a, b) => a - b);
  for (let i = 0; i < nums.length; i++) {
    // 核心大于0是就直接停止循环
    if (nums[i] > 0) break;
    // 针对i去重
    if (i > 0 && nums[i] == nums[i - 1]) {
      continue;
    }
    // 定义双指针
    let l = i + 1;
    let r = nums.length - 1;
    // 结束标志是 不重叠，l小于p
    while (l < r) {
      let sum = nums[i] + nums[l] + nums[r];
      if (sum === 0) {
        result.push([nums[i], nums[l], nums[r]]);
        // 针对左右指针进行去重
        while (r > l && nums[r] === nums[r - 1]) r--;
        while (r > l && nums[l] === nums[l + 1]) l++;
        l++;
        r--;
      } else if (sum < 0) {
        l++;
      } else if (sum > 0) {
        r--;
      }
    }
  }
  return result;
};
```

