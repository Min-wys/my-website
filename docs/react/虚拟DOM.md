## 虚拟DOM

- ### 什么是虚拟DOM

  - 一个能代表DOM树的对象，通常包含标签名、标签上的属性、事件监听和子元素们、以及其他属性

- ### 虚拟DOM的优点

  - #### 提高开发效率

    - 使用`JavaScript 或` `jQuery` ，我们在编写应用程序时，还需关注如何去更新`DOM`。
    - 使用`React`，因为有数据驱动视图，你只需要告诉`React`你想让视图处于什么状态，`React`则通过`VitrualDom`确保`DOM`与该状态相匹配。你不必自己去完成属性操作、事件处理、`DOM`更新，`React`会替你完成这一切。
    - 这让我们**更关注我们的业务逻辑而非`DOM`操作**，这一点即可大大提升我们的开发效率。

  - #### 跨浏览器兼容

    - `React`基于`VitrualDom`自己实现了一套自己的事件机制（合成事件），自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，**抹平了各个浏览器的事件兼容性问题**。

  - #### 跨平台兼容

    - `VitrualDom`为`React`带来了跨平台渲染的能力，**虚拟DOM其实就是一层抽象层，可以让我们写的代码在多端表现一致**
    - 以`React Native`为例子。`React`根据`VitrualDom`画出相应平台的`ui`层，只不过不同平台画的姿势不同而已。

  - ### 提高性能

    - 减少DOM操作
      - 虚拟DOM可以将多次操作合并成一个操作，比如添加1000个节点，直接取操作真实DOM，是一个一个的进行添加
      - 虚拟DOM借助DOM diff算法可以吧多余的操作省掉，比如添加1000个节点，原有990个，10个新增，就会去操作这十个

- ### 虚拟DOM的缺点

  - 需要额外的创建的函数，如createElement，但是可以通过JSX进行简化成XML写法
  - 过度的依赖的打包工具，（vue-loader babel）React通过babel将JSX转换成createElement形式

## diff算法

- ### 什么是diff算法

  - 一种对比新/旧虚拟DOM树的高效算法，能快速计算哪些虚拟DOM树发生了变化，从而只更新局部DOM。


  - 传统的 diff 算法性能开销大，无法满足大规模 DOM 操作需求。 React 通过制定大胆的策略，将性能开销降到最低。


- ### diff 策略

  - Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。

  - 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。

  - 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。


- 基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。


### tree diff

- 基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。


- 既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。


![](https://pic1.zhimg.com/80/0c08dbb6b1e0745780de4d208ad51d34_hd.png)

- **问题：如果出现了 DOM 节点跨层级的移动操作，性能不好！**

![](https://pic2.zhimg.com/80/d712a73769688afe1ef1a055391d99ed_hd.png)

- 如上图所示：React diff 的执行情况：create A -> create B -> create C -> delete A


- 由此可发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。


> 注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。

### component diff 

- React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。

  - 如果是同一类型的组件，按照原策略继续tree diff。

  - 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。

  - 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。


### element diff

- 如下图，老集合中包含节点：A、B、C、D，更新后的新集合中包含节点：B、A、D、C，此时新老集合进行 diff 差异化对比，发现 B != A，则创建并插入 B 至新集合，删除老集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D。


![](https://pic2.zhimg.com/80/7541670c089b84c59b84e9438e92a8e9_hd.png)

- React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。


- 针对这一现象，React 提出优化策略：**允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！**


- 新老集合所包含的节点，如下图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。


![](https://pic4.zhimg.com/80/c0aa97d996de5e7f1069e97ca3accfeb_hd.png)

- 问题：如下图所示，若新集合的节点更新为：D、A、B、C，与老集合对比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在老集合的位置是最大的，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面的现象。


![](https://pic1.zhimg.com/80/7b9beae0cf0a5bc8c2e82d00c43d1c90_hd.png)

> 建议：在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。

### 总结

- React 通过分层求异的策略，对 tree diff 进行算法优化；
- React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；
- React 通过设置唯一 key的策略，对 element diff 进行算法优化；
- 建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；
- 建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。

##  React 中 keys 的作用是什么？

- 虚拟 DOM 的 key 的作用?

  - 简单说: key 是虚拟 DOM 对象的标识, 在更新显示时 key 起着极其重要的作用
  - 详细说: 当列表数组中的数据发生变化生成新的虚拟 DOM 后, React 进行新旧虚拟 DOM 的 diff 比较
    - key 没有变
      - item 数据没变, 直接使用原来的真实 DOM
      - item 数据变了, 对原来的真实 DOM 进行数据更新
    - key 变了
      - 销毁原来的真实 DOM, 根据 item 数据创建新的真实 DOM 显示(即使 item 数据没有变)

- key 为 index 的问题

  - 添加/删除/排序 => 产生没有必要的真实 DOM 更新 ==> 界面效果没问题, 但效率低

  - 如果 item 界面还有输入框 => 产生错误的真实 DOM 更新 ==> 界面有问题

    - ```js
      [{key:1,value:你},{key:2,value:我},{key:3,value:他}]----删除第二个（我）
      [{key:1,value:你},{key:2,value:我}]----和我们想的不一样，‘我’没有删除，删除了‘他’
      原因是：我们用了下标做key，删除元素后，下标的值是会变化的（[{key:1,value:你},{key:2,value:他}]），diff算法时发现key值是1、2，算法会认为1、2没有变，只是删除了3，所有最终显示的是[{key:1,value:你},{key:2,value:我}]，将‘他删除’
      ```

  - 注意: 如果不存在添加/删除/排序操作, 用 index 没有问题

- 解决:

  - 使用 item 数据的标识数据作为 key, 比如 id 属性值
